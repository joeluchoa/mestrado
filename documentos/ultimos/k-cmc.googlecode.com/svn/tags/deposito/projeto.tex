%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                  Fábio Pisaruk
%%
%%%%%%%%%%%%%%%%   Feito entre:  06/09/2007 a ????????    %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\documentclass{amsart}

\documentclass[12pt]{amsart}

%% Escrevendo em português:
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}
\usepackage[dvips]{graphicx,psfrag}
\usepackage{multicol}
\usepackage{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\contentsname}{2.\enspace Índice}
\renewcommand{\refname}{Bibliografia}
\renewcommand{\datename}{\textit{Data}:}
\makeatletter 
\renewcommand{\l@subsection}{\@tocline{2}{1pt}{2pc}{5pc}{}}
\makeatother
\setcounter{tocdepth}{2}

%% definicao personalizada
\usepackage{./estilo/estilo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Floating package
\usepackage{floatflt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Dimensão da página
%\setlength{\topmargin}{-1.0cm}
%\setlength{\textheight}{22.0cm}
%\setlength{\textwidth}{15.0cm}

%\setlength{\parskip}{.5pc}
\setlength{\paperwidth}{216mm}
\setlength{\paperheight}{279mm}
\setlength{\textwidth}{150mm}
\setlength{\textheight}{220mm}
\setlength{\topmargin}{1cm}
 
% margens impar e par da pagina
%\setlength\oddsidemargin{.2cm}  
%\setlength\evensidemargin{.2cm}  
\setlength\oddsidemargin{.6cm}  
\setlength\evensidemargin{.6cm}  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\fimprova}{
\hspace*{\fill}
\rule{0.15cm}{0.3cm}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title[$k$-menores caminhos]% 
{$k$-menores caminhos}
\author{Fábio Pisaruk}
\dedicatory{\small {\rm Orientador:} {\rm José Coelho de Pina}} 
\address{Instituto de Matemática e Estatística, Universidade de São Paulo, Rua
  do Matão 1010, 05508--900~São Paulo, SP}
\email{pisaruk@ime.usp.br}
\keywords{menores caminhos, caminhos mínimos, otimização combinatória}
\date{\today}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Neste projeto, fazemos um esboço de uma dissertação de mestrado que
pretende estudar algoritmos desenvolvidos para geração
de $k$-menores caminhos em grafos com custos
não-negativos, bem como algumas implementações destes.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\input{} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\tableofcontents  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{section}0


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Introdução
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introdução}

\par
\begin{floatingfigure}[l]{30mm}
\begin{center}
  \psfrag{s}{$s$}
  \psfrag{t}{$t$}
  \includegraphics{./figs/rede}
\end{center} 
\end{floatingfigure}
\noindent


Uma certa empresa de telecomunicações, cujo nome real não será
citado por razões de confidencialidade, mas que para nossa
comodidade será chamada de TeleMax, fornece linhas de transmissão
aos seus clientes de modo que estes possam, por exemplo, ligar-se
às suas filiais por linhas privadas.
Para tal, conta com uma infra-estrutura (rede) bastante complexa
compreendendo cabos e diversos equipamentos de junção.  Esta rede
é \textit{full-duplex}, ou seja, possui passagem de dados em ambos os
sentidos.  Para entender o processo de fornecimento de linhas de
transmissão, passaremos a um exemplo.  A empresa SoftSOF
possui duas sedes, uma em Santos e outra em Fernandópolis e, deseja interligar suas
filiais com uma qualidade mínima de 200 Kbits/s, em pico de uso.
A SoftSOF possui 10 computadores em cada uma de suas filiais, logo
precisaríamos de um link de 200 Kbits/s * 10 = 2000 Kbits/s.
É solicitado à TeleMax um \textit{link} de 2000 Kbits/s ligando as suas sedes.
A TeleMax não possui uma ligação direta entre as duas cidades,
entretanto possui uma ligação que passa por São José do Rio
Preto, ou seja, um caminho Santos - São José Do Rio Preto -
Fernandópolis.  Infelizmente, este link só dispõe de 1024 Kbits/s.
No entanto, observando-se sua infra-estrutura, descobre-se que existe um outro
caminho: Santos - São Paulo - Fernandópolis, também com
capacidade de 1024 Kbits/s.  Pronto. A TeleMax pode fornecer o link
requerido pela SoftSOF, bastando para isso utilizar os dois
caminhos acima descritos, totalizando os 2048 Kbits/s, um pouco acima do requerido.

\par
\begin{figure}[htbp]
\begin{center}
\psfrag{Fernandopolis}{{\tiny Fernandópolis}}
\psfrag{Sao Paulo}{{\tiny São Paulo}}
\psfrag{Sao Jose do Rio Preto}{{\tiny São José do Rio Preto}}
\psfrag{Santos}{{\tiny Santos}}
\psfrag{2000 Kbits}{{\tiny 2000 Kbits/s}}
\psfrag{1024 Kbits}{{\tiny 1024 Kbits/s}}
\psfrag{labela}{($a$)}
\psfrag{labelb}{($b$)}
\includegraphics[width=1\textwidth]{./figs/introducaoTeleMax.eps}
   \caption{Em ($a$) vemos um esquema solicitação da SoftSOF, um link de 2000 Kbits/s entre as filiais. Em ($b$) está descrita a solução encontrada pela TeleMax, com base na disponibilidade de sua rede.}
\end{center} 
\end{figure}
\noindent
Vamos a algumas considerações relevantes. O custo de um caminho é 
função da quantidade de equipamentos usada e não da distância total 
dos cabos que o compõe.
Isto se deve ao custo elevado dos equipamentos se comparado ao dos cabos. 
Assim, passa a ser melhor utilizar uma ligação que percorra uma distância 
maior mas que passa por um número menor de equipamentos, do que uma com 
menor distância mas que se utiliza de mais equipamentos.


A justificativa para a geração de diversos caminhos no lugar de apenas
um está relacionada à capacidade de transmissão disponível por cabo.  A
motivação para a geração dos menores caminhos, ou seja, com utilização
mínima de equipamentos, requer uma explicação mais detalhada.  Até agora
fomos simplistas ao tratarmos das relações entre cabos e equipamentos
como se um equipamento se ligasse a apenas um cabo.  Na verdade, cada
equipamento se liga a um grande número de cabos.  Assim, podemos ter
diversos caminhos entre dois equipamentos, um para cada cabo.  A fim de
utilizarmos bem os recursos da rede é interessante que o menor número
de equipamentos esteja alocado para cada cliente pois, desta maneira, um
número maior de ligações poderá ser oferecido pela TeleMax.  Embora a
utilização do menor número possível de equipamentos para cada cliente
não seja suficiente para garantir que a rede esteja sendo utilizada de
maneira eficiente, não nos importaremos com isto neste trabalho.  Feitas
as devidas considerações, vamos agora justificar a automação do
processo.

Imagine levar a cabo o processo de fornecimento de linhas manualmente.  
Podemos salientar alguns problemas da abordagem manual.  Devido às dimensões da rede, o
operador responsável levará muito tempo para obter uma lista de caminhos
entre os pontos.  Durante o tempo em que o operador gastar analisando a
rede, esta poderá ter sofrido alterações, as quais não serão levadas em
conta por ele.  Além disso, sabemos como as pessoas são suscetíveis a
falhas, ainda mais quando expostas a atividades maçantes e repetitivas.
Por conta destes fatores, a TeleMax sentiu a necessidade de uma
ferramenta computacional que gerasse de maneira rápida e confiável uma
série de caminhos entre dois pontos da sua rede.

Na construção da ferramenta, consideramos a rede
como um grafo simétrico, por ser full-duplex, onde as arestas são
representadas pelos cabos e os vértices pelos equipamentos.  A
ferramenta tinha como núcleo o algoritmo desenvolvido por Naoki Katoh,
Toshihide Ibaraki e H. Mine~\cite{katoh:n-12-411}, 
de geração de menores caminhos.  Os caminhos de mesmo custo,
ou seja, que se utilizam de igual quantidade de equipamentos, são
posteriormente reordenados crescentemente pela distância total
percorrida por seus cabos.  
Esta dissertação trata de algoritmos que produzem caminhos de menor custo em grafos.
Embora algoritmos para tal sejam de interesse teórico, é curioso
observar que foi uma aplicação prática, demandada por uma necessidade
surgida no âmbito empresarial, que nos levou ao estudo destes.
 


%% Otimização combinatória é um campo da matemática aplicada que usa
%% técnicas de combinatória, programação matemática e teoria de algoritmos
%% para resolver problemas em otimização sobre estruturas discretas.

%% Problemas em otimização combinatória têm sido um tópico central para a evolução de algoritmos e da teoria de complexidade computacional.
%% Pesquisadores têm apresentado muitas idéias criativas para o projeto de algoritmos eficientes baseados em conceitos e resultados na área. 
%% Métodos desenvolvidos para problemas em fluxos em redes, como o primal-dual, têm se mostrado muito úteis no projeto e análise de uma variedade de
%% algoritmos para problemas em outros domínios. 
%% Muitas das idéias inovadoras têm se baseado em um conjunto não muito grande de princípios  comuns que são
%% simultaneamente simples e poderosos (como \textit{scaling}).

%% Neste projeto pretendemos estudar algumas das ferramentas mais
%% fundamentais em otimização combinatória. Desejamos
%% analisar e implementar algoritmos para diversos problemas
%% clássicos, principalmente em fluxos em redes e
%% emparelhamentos.  O nosso guia nessa jornada será o livro de
%% Ahuja, Magnanti e Orlin~\cite{ahuja:netflows}, com o livro de
%% Cook, Cunningham, Pulleyblank e
%% Schrijver~\cite{cook:co-1998} como um guia secundário. Para
%% os tópicos mais teóricos consultaremos os livros de
%% Schrijver~\cite{schrijver:tilp-1986,schrijver:cope-2003}.
%% Criaremos um sítio na internet para armazenar todas as
%% implementações, textos e animações produzidas durante a
%% execução do projeto.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  GRAFOS PASSEIOS E CAMINHOS 
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 

\section{Grafos, passeios e caminhos}


Estão descritos nesta seção os ingredientes básicos que envolvem os
problemas que serão tratados. A notação básica que utilizamos é a de
Paulo Feofillof~\cite{pf:aula}

Um \defi{grafo}\index{grafo} é um objeto da forma $(V,A)$, 
onde $V$ é um conjunto finito e $A$ é um conjunto de pares ordenados 
de elementos de $V$. 

Os elementos de $V$ são chamados \defi{vértices}\index{vértices@vértices} e os
elementos de $A$ são chamados \defi{arcos}\index{arcos}.  Para cada arco
$(u,v)$, os vértices $u$ e $v$ representam a ponta inicial e a ponta final de
$(u,v)$, respectivamente.  Um arco $(u,v)$ também poderá ser representado por
$uv$.

Um grafo é \defi{simétrico}\index{grafo!simétrico@simétrico} 
se para cada arco $uv$ existir também o arco $vu$. Diremos às vezes
que o arco $vu$ é \defi{reverso}\index{arco!reverso}
 do arco $uv$ e que o par $\{(u,v),(v,u)\}$ é uma \defi{aresta}\index{aresta}.
 
Um grafo pode ser naturalmente representado através de um
diagrama, como o da figura~\ref{fig:grafo}, onde os vértices são
pequenas bolas e os arcos são as flechas ligando estas bolas. 

\begin{figure}[htbp]
 \begin{center}
    \psfrag{(a)}{$\iten{a}$}
    \psfrag{(b)}{$\iten{b}$}
    \psfrag{(c)}{$\iten{c}$}
    \psfrag{(d)}{$\iten{d}$}
    \psfrag{a}{{$a$}}
    \psfrag{b}{{$b$}}
    \psfrag{c}{{$c$}}
    \psfrag{d}{{$d$}}
    \psfrag{e}{{$e$}}   
    \psfrag{f}{{$f$}}
  \includegraphics{./figs/grafo.eps}
  \caption{\label{fig:grafo} $\iten{a}$, $\iten{b}$, $\iten{c}$ e 
    $\iten{d}$ são exemplos de grafos. $\iten{b}$ é um grafo simétrico.}
 \end{center}
 \end{figure}

%%% Passeio 
 Um \defi{passeio}\index{passeio} num grafo $(V,A)$ é qualquer seqüência da forma
 \begin{eqnarray}
 \label{passeio}
 \seq{v_{0}, a_{1}, v_{1}, \ldots, a_{t}, v_{t}}
 \end{eqnarray}
onde $v_{0}, \ldots, v_{t}$ são vértices, $a_{1}, \ldots, a_{t}$ 
são arcos e, para cada $i$, $a_{i}$ é o arco $v_{i-1}v_{i}$. 
O vértice
$v_{0}$ é o \defi{início} ou \defi{ponta inicial} do passeio
e o $v_{t}$ é seu \defi{término} ou \defi{ponta final}.
%Uma \defi{passeio não-orientado}\index{passeio! não orientado@não orientado}
%é uma seqüência como (\ref{passeio}) onde,
%para cada $i$, $\alpha_{i}$ é o arco $v_{i-1}v_{i}$ ou o arco
% $v_{i}v_{i-1}$. 
Na figura~\ref{fig:grafo}$\iten{a}$ a seqüência
$\seq{a, ab, b, be, e, ef, f, fd, d, db, b, be, e, ef, f}$ é um passeio com início em $a$ e 
 término em $f$.
% e a seqüência $\seq{a, ac, c, ce, e, be, b, bd, d,df,f}$
% é um passeio não-orientado com início em $a$ e término em $f$. 

%%%% 
Se $P:=\seq{v_{0}, a_{1}, v_{1}, \ldots, a_{t}, v_{t}}$, então qualquer 
subseqüência da forma  
 \begin{eqnarray}
  \label{subpasseio}
   \seq{v_{i}, a_{i+1}, v_{i+1}, \ldots, a_{j}, v_{j}}
 \end{eqnarray}
com $0 \leq i \leq j \leq t$ será um \defi{sub-passeio} de $P$. 
Além disso, se $i=0$,  então o sub-passeio será dito um 
\defi{prefixo} de $P$.
Na figura~\ref{fig:grafo}$\iten{a}$ a seqüência $\seq{a, ab, b, be, e, ef, f,
fd, d}$ é um sub-passeio e prefixo de do passeio 
$\seq{a, ab, b, be, e, ef, f, fd, d, db, b, be, e, ef, f}$.


%%% Caminhos
Um \defi{caminho}\index{caminho} é um passeio
sem vértices repetidos.
%Um \defi{caminho não-orientado}\index{caminho!não-orientado@não-orientado} 
%é um passeio não-orientado sem vértices repetidos.
Na figura~\ref{fig:grafo}$\iten{a}$ a seqüência
 $\seq{a, ab, b, be, e, ef, f}$ é um caminho com início em $a$ e 
 término em $f$.
% e a seqüência $\seq{a, ac, c, ce, e, be, b, bd, d, df,
% f}$ é um caminho não-orientado com início em $a$ e término em $f$. 

 
%
% função custo
%

Uma \defi{função custo}\index{função@função!custo}\index{custo} em
$(V,A)$ é uma função de $A$ em $\NonnegInt$. Se $c$ for uma função
custo em $(V,A)$ e $uv$ estiver em $A$, então
$c(u,v)$ será o valor de $c$ em $uv$. 
%
% Custo de um passeio e passeio de custo mínimo.
% 
Se $P$ for um passeio em um grafo $(V,A)$ e $c$ uma função custo, 
denotaremos por $c(P)$ o \defi{custo do caminho} $P$%
\index{custo do caminho}, ou seja, $c(P)$ é o somatório dos custos
de todos os arcos em $P$.  Um passeio $P$ tem \defi{custo mínimo} se
$c(P) \leq c(P')$ para todo passeio $P'$ que tenha o mesmo início e término
que $P$. Um passeio de custo mínimo é comumente chamado de \defi{caminho
mínimo}.
 
%
% Problema dos menores caminhos 
% 
 
Um problema fundamental em otimização combinatória que tem um papel de
destaque neste projeto é o 
\defi{problema do caminho mínimo}, denotado por 
\PCM:\index{problema!do caminho mínimo@do caminho mínimo}
 \begin{quote}
   \textbf{Problema} \PCM$(V,A,c,s,t)$: 
   \index{\PCM}\mar{\PCM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   Dado um grafo $(V,A)$, uma função
   custo~$c$ e dois vértice $s$ e $t$, 
   encontrar um caminho de custo mínimo 
   de $s$ a~$t$.
 \end{quote}
Na literatura essa versão é conhecida como \textit{single-pair shortest path
problem}\index{single-pair shortest path@single-source shortest path}. 
O celebrado algoritmo de Edsger Wybe Dijkstra~\cite{dijkstra59:note} 
resolve o problema do caminho mínimo.



Denotaremos, quando não houver
ambigüidade, por $n$ e $m$ os números $|V|$ e $|A|$, respectivamente.
Além disso, representaremos por $T(n,m)$ o consumo de tempo de uma
subrotina genérica para resolver o \PCM\ em um grafo com $n$ vértices
e $m$ arestas.
O algoritmo mais eficiente  conhecido para o \PCM\ foi 
projetado por Michael L. Fredman e Robert Endre
Tarjan~\cite{FredTarjan:Fibonacci}
e consome tempo $\Oh(m + n \log n)$. Existe ainda um algoritmo que consome
tempo linear \textit{sob um outro modelo de computação} que foi
desenvolvido por Mikkel Thorup~\cite{thorup:sssp-1999}.    




\section{Árvores dos prefixos}


Descrevemos aqui uma ``arborescência rotulada'' que de certa forma
codifica os prefixos dos caminhos em uma dada coleção.
Esta representação será particularmente útil quando, mais
adiante, discutirmos o método de Yen.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
No que segue $\Qcal$ é uma coleção de caminhos de um grafo e  
$V(\Qcal)$ e $A(\Qcal)$ são o conjunto dos vértices e o
conjunto dos arcos presentes nos caminhos, respectivamente.

Um grafo acíclico $(N,E)$ com $|N| = |E| + 1$ é uma
\defi{arborescência}\index{arborescencia@@arborescência} 
se todo vértice, exceto um 
vértice especial chamado de \defi{raiz}\index{raiz da arborescência@@raiz da
arborescência},
 for ponta final de exatamente um arco. 
Será conveniente tratarmos os vértices 
 de uma arborescência por \defi{nós}. 
Uma arborescência está ilustrada na 
figura~\ref{fig:grafo}(c). 
A raiz dessa arborescência é o
nó $a$. Uma \defi{folha}\index{folha de uma arborescência@@folha de uma
arborescência}
 de uma arborescência é um nó
que não é ponta inicial de nenhum arco. 


Suponha que $(N,E)$ seja uma arborescência e  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$f$ uma \defi{função rótulo}\index{função@função!rotulo@rótulo} 
que associa a cada nó em $N$ um vértice em $V(\Qcal)$ e a
cada arco em $E$ um arco em $A(\Qcal)$. 
Se 
\begin{eqnarray*}
 R=\seq{u_{0}, e_{1}, u_{1}, \ldots, e_{t}, u_{t}}
\end{eqnarray*}
for um caminho em  $(N,E)$, então
\begin{eqnarray*}
 f(R):=\seq{f(u_{0}), f(e_{1}), f(u_{1}), \ldots, f(e_{t}), f(u_{t})}
\end{eqnarray*}
será uma seqüência de vértices e arcos dos caminhos em $\Qcal$.
Diremos que $(N,E,f)$ é \defi{árvore dos prefixos} de $\Qcal$ se 
\begin{enumerate}[(p1)]
\item para cada caminho $R$ em $(N,E)$ com início na
      raiz, $f(R)$ for prefixo de algum caminho em $\Qcal$; e
\item para cada prefixo $Q$ de algum caminho em $\Qcal$
      existir um caminho $R$ em $(N,E)$ com início na
      raiz tal que $f(R)=Q$; e
\item o caminho $R$ do item anterior for único. 
\end{enumerate}

Não é verdade que para cada coleção $\Qcal$ de caminhos em
um grafo existe uma árvore dos prefixos de $\Qcal$.
No entanto, se todos os caminhos em $\Qcal$
tiverem a mesma ponta inicial, então existe uma árvore dos prefixo de
$\Qcal$ e esta é única. Na figura~\ref{fig:prefixo}(b) vemos 
a ilustração da árvore dos prefixos de quatro caminhos de $s$ a~$t$ no grafo
da figura~\ref{fig:prefixo}(a). Na árvore da ilustração $w,x,y$ 
e $z$ são nós e $f(w)=s, f(x)=a, f(y)=d$ e $f(z)=d$.

\begin{figure}[htbp]
 \begin{center}
    \psfrag{(a)}{$\iten{a}$}
    \psfrag{(b)}{$\iten{b}$}
    \psfrag{a}{{$s$}}
    \psfrag{b}{{$a$}}
    \psfrag{c}{{$b$}}
    \psfrag{d}{{$c$}}
    \psfrag{e}{{$d$}}   
    \psfrag{f}{{$t$}}
    \psfrag{x}{{$x$}}
    \psfrag{y}{{$y$}}
    \psfrag{z}{{$z$}}
    \psfrag{w}{{$w$}}
    \psfrag{grafo}{grafo}
    \psfrag{arvore dos prefixos}{árvore dos prefixos}
  \includegraphics{./figs/prefixo.eps}
  \caption{\label{fig:prefixo} (b) mostra a árvore dos prefixos dos
   caminhos
   $\seq{s,a,c,t}$,
   $\seq{s,a,d,t}$,
   $\seq{s,b,a,c,t}$ e 
   $\seq{s,b,a,d,c,t}$ no grafo em~(a).
  Na árvore, um símbolo ao lado de um nó é o rótulo desse nó.
  Os rótulos dos arcos não estão representados na figura. O símbolo 
  dentro de um nó é o seu nome.
  }
 \end{center}
 \end{figure}

\section{Problema dos $k$-caminhos}

O problema central deste projeto se assemelha muito ao  
do $k$-ésimo menor elemento, que é estudado em disciplinas 
básicas de análise de algoritmos:
 \begin{quote}
   \textbf{Problema} \kesimo$(\Scal,k)$:%
 \index{\kesimo}\mar{\kesimo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   Dado um conjunto $\Scal$ de números inteiros 
   e um número inteiro positivo
   $k$, encontrar o $k$-ésimo menor elemento de $\Scal$.
 \end{quote}
Os algoritmos conhecidos para o problema \kesimo\ são
facilmente adap\-tá\-veis para, além do $k$-ésimo menor, fornecerem, em tempo 
linear, os $k$ menores elementos de $\Scal$ \textit{em ordem crescente}.

A diferença entre o problema \kesimo\ e o problema que
consideraremos é que o conjunto $\Scal$ dado é ``muito grande'' e, portanto,
nos é dado de uma maneira compacta, o que torna o problema sensivelmente
mais difícil do ponto de vista computacional. 
%O conjunto $\Scal$ será o conjunto de caminhos entre dois vértices
%determinados  em um grafo com custo
%nas nos arcos. 
Adiante tornamos o problema mais preciso.  

Suponha que $(V,A)$ seja um grafo, $c$ uma função custo e $s$ e $t$ 
dois de seus vértices. Considere o conjunto $\Pcal_{st}$ de todos $st$-caminhos,
ou seja, caminhos de $s$ a~$t$. 
Uma lista $\seq{P_1,\ldots,P_k}$ $st$-caminhos  distintos é de \defi{custo mínimo} se 
$$
c(P_1) \leq c(P_2) \leq \cdots \leq c(P_k) \leq \min\{ c(P) : P
\in \Pcal -\{P_1,\ldots,P_k\}\}.
$$
De uma maneira mais breve, diremos que $\seq{P_1,\ldots,P_k}$ são 
\defi{$k$-menores caminhos} (de $s$ a~$t$).

Em termos da teoria dos grafos o  problema que foi discutido na 
introdução é o \defi{problema dos $k$-menores caminhos}\index{problema!dos
k-menores caminhos@do $k$-menores caminhos}, denotado por \kCM:
 \begin{quote}
   \textbf{Problema} \kCM$(V,A,c,s,t,k)$:%
   \index{\kCM}\mar{\kCM}
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   Dado um grafo $(V,A)$, uma função
   custo $c$, dois vértice $s$ e $t$ e um inteiro positivo $k$, 
   encontrar $k$-caminhos de custos mínimos 
   de $s$ a~$t$.
 \end{quote}
É evidente que o \PCM\ nada mais é que o \kCM\ com $k=1$.

O \kCM\ é, em essência, o problema \kesimo\ com $\Pcal_{st}$ no papel do
conjunto $\Scal$. A grande diferença computacional é que o conjunto
$\Pcal_{st}$ não é fornecido explicitamente, mas sim de uma maneira
compacta: um grafo, uma função custo e um par de vértices. Desta
forma, o número de elementos em $\Pcal_{st}$ é potencialmente exponencial no
tamanho da entrada, tornando impraticável resolvermos o \kCM\
utilizando meramente algoritmos para o \kesimo\ como subrotina.

Na próxima seção é descrito o método genérico para resolver o \kCM.
Este método é um passo intermediário para chegarmos no método desenvolvido 
por Jin Y. Yen~\cite{yen:ms-17-712}  para o \kCM.
Antes disto, apresentamos aqui um problema intimamente 
relacionado ao \kCM\ e que também é considerado por este projeto: 

\begin{quote}
  \textbf{Problema} \KCM$(V,A,c,s,t,K)$:%
  \index{\KCM}\mar{\KCM}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Dado um grafo $(V,A)$, uma função
  custo $c$, dois vértice $s$ e $t$ e um inteiro positivo $K$, 
  encontrar os caminhos de $s$ a~$t$ de custos não superiores a $K$.
\end{quote}


\section{Método genérico}

A descrição que fazemos é, de certa forma, \textit{top-down}. 
Começaremos com um método genérico que será refinado a cada passo incluindo,
convenientemente, algumas subrotinas auxiliares.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
O nosso interesse aqui é numa descrição mais conceitual em que 
a correção e o consumo de tempo polinomial do método sejam um tanto quanto
evidentes. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Não temos a intenção de descrever um algoritmo com o menor consumo de tempo. 

O método abaixo recebe um grafo $(V,A)$, uma função custo, dois vértices $s$ e
$t$ e um inteiro positivo $k$ e devolve uma lista $\seq{P_1,\ldots,P_k}$ de
$k$-menores caminhos de $s$ a~$t$.

\begin{algoritmo}

\textbf{Método} \Generico{} $(V,A,c,s,t,k)$ %\\[2mm]
   
0\x $\Pcal \larr \mbox{conjunto dos caminhos de $s$ a~$t$}$ 

1\x \para{} $i=1,\ldots,k$ \faca %\\[1mm]

2\xx  $P_i \larr \mbox{caminho de custo mínimo em $\Pcal$}$ %\\[1mm]

3\xx  $\Pcal \larr \Pcal - P_i$

4\x \devolva{} $\seq{P_1,\ldots,P_k}$

\end{algoritmo}


No início de cada iteração da linha~1 o conjunto $\Pcal$ contém os
candidatos a $i$-ésimo caminho mínimo de $s$ a~$t$. 
O método de Yen é uma elaboração do método \Generico.
Em vez do conjunto 
$\Pcal$, Yen mantém, pelo menos conceitualmente, uma partição
$\Pi$ de $\Pcal$.
Em cada iteração, é escolhido o caminho mais barato
dentre um conjunto $\Lcal$ formado por \textit{um} caminho 
mínimo $P_{\pi}$ representante de
cada parte $\pi$ de~$\Pi$ e depois a partição é atualizada. 

\begin{algoritmo}

\textbf{Método} \YenGenerico{} $(V,A,c,s,t,k)$ %\\[2mm]
   
0\x $\Pi \larr \{\{\mbox{conjunto dos caminhos de $s$ a~$t$}\}\}$

1\x $\Qcal \larr \emptyset $

2\x \para{} $i=1,\ldots,k$ \faca %\\[1mm]

3\xx  $\Lcal  \larr \seq{P_{\pi} : P_{\pi} \ \mbox{é caminho mínimo da parte $\pi$
de~$\Pi$}}$

4\xx  $P_i \larr \mbox{caminho de custo mínimo em $\Lcal$}$ %\\[1mm]

5\xx  $\Qcal \larr \Qcal \cup \{P_i\}$

6\xx  $\Pi \larr \AtualizeGenerico~(V,A,\Qcal)$

7\x \devolva{} $\seq{P_1,\ldots,P_k}$

\end{algoritmo}

Como veremos, a eficiência do método de Yen dependerá fortemente da estrutura
restrita dos caminhos nas partes de~$\Pi$: cada parte é formada por
caminhos que têm um certo prefixo comum. 

Seja $\Pcal_{st}$ a coleção
dos caminhos de $s$ a~$t$ em $(V,A)$.
Suponha que $\Qcal$ seja a lista de 
caminhos distintos de $s$ a~$t$ na linha~5 do método
\YenGenerico{}.  Passamos a descrever a partição
$\Pi$ dos caminhos em $\Pcal := \Pcal_{st} \setminus \Qcal$.
Para isto é conveniente utilizarmos a 
\textit{árvore dos prefixos} de
$\Qcal$, como foi feito por John Hershberger,
Matthew Maxel e Subhash Suri~\cite{hershberger:acmta-3-??}.

No que segue suponha que $(N,E,f)$ seja 
a árvore dos prefixos de $\Qcal$ e $u$ seja um nó em $N$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Representaremos por $R_u$\mar{$R_u$} o
caminho da raiz a $u$ na árvore. Assim,  $f(R_u)$\mar{$f(R_u)$} é
o prefixo de um caminho em $\Qcal$. 
Por exemplo, na árvore dos prefixos da figura~\ref{fig:prefixo}(b)
temos que $R_y = \seq{w,wx,x,xy,y}$ e $f(R_y) = \seq{s,sa,a,ad,d}$.

Seja\mar{$A_u$}
%$A_u$ a
%coleção dos arcos em $A$ com ponta inicial em $f(u)$ e
%ponta final $f(w)$ para todo arco $uw$ em $E$, isto é,
\begin{eqnarray*}
A_u := \{ (f(u),f(w)) : uw \in E\}. 
\end{eqnarray*}  
e seja $\pi_u$\mar{$\pi_u$} o conjunto dos caminhos em $\Pcal$ com
prefixo $f(R_u)$ e que não possuem arcos em~$A_u$.
Para o exemplo na figura~\ref{fig:prefixo} temos que 
\begin{eqnarray*}
A_w = \{sa,sb\}, 
A_x = \{ac,ad\}, 
A_y = \{dt\} \ \mbox{e} \ 
A_z = \{dc\} \\
\pi_w = \emptyset, 
\pi_x = \emptyset,
\pi_y = \{\seq{s,a,d,c,t}\},  \ \mbox{e} \
\pi_z = \{\seq{s,b,a,d,t}\}.  
\end{eqnarray*}

A partição~$\Pi$\mar{$\Pi$} é formada por uma parte $\pi_u$ para
cada vértice $u$ em $N$, ou seja,
\[
\Pi := \{\pi_u : u \in N\}.
\]
No início de cada iteração da linha~2 o número de partes é certamente não
superior a $n \times i$.
O algoritmo \AtualizeGenerico{} resume toda a discussão acima.


\begin{algoritmo}

\textbf{Algoritmo} \AtualizeGenerico{} $(V,A,\Qcal)$ %\\[2mm]
   
0\x $\Pi \larr \emptyset \quad \quad \Pcal \larr \Pcal_{st} \setminus \Qcal$

1\x $(N,E,f) \larr$ árvore dos prefixos de $\Qcal$

2\x \para{} \cada{} $u \in N$ \faca %\\[1mm]

3\xx  $\pi_u \larr \{\mbox{caminhos em $\Pcal$ com prefixo $f(R_u)$}$

\xxxxx \quad e que não possuem arcos em $A_u \}$

4\xx  $\Pi \larr  \Pi \cup \{\pi_u\}$ %\\[1mm]

5\x \devolva{} $\Pi$

\end{algoritmo}

Podemos verificar que cada caminho em $\Qcal$ não pertence a
nenhuma parte de~$\Pi$. Também podemos verificar que cada
caminho $P$ em $\Pcal$ está em uma única 
parte de~$\Pi$. De fato, seja $P'$ o maior prefixo de~$P$ 
que é prefixo de algum caminho em $\Qcal$. Pela definição
de árvore de prefixos, existe um único caminho $R'$ em 
$(N,E)$ com início na raiz e tal que $P' = f(R')$. 
Para o vértice $u$ término de $R'$ temos que $P$ está em
$\pi_u$ e é a única parte que possui $P$. 

Desta forma, no início de cada iteração das linhas
2--6  do método \YenGenerico{}, $\Pi$ é uma partição de
$\Pcal$, portanto a correção
do método é evidente.


%% ???Ainda utilizando a estrutura da árvore dos prefixos de  

As árvores dos prefixos de duas
execuções consecutivas do algoritmo \AtualizeGenerico{} são
muito semelhantes: apenas um novo caminho é acrescentado à
árvore anterior.  Isto, em particular, significa que as
partições de duas iterações consecutivas das linhas 2--6 do
método \YenGenerico{} são muitos semelhantes. Esta
observação pode ser utilizada para o algoritmo
\AtualizeGenerico{} obter mais eficientemente
uma partição a partir da partição anterior.
 





\section{Método de Yen}

O método que Jin Y. Yen~\cite{yen:ms-17-712} desenvolveu para resolver
o \kCM{} parece ter um papel central entre os algoritmos que foram
posteriormente projetados para o \kCM\ ou mesmo para versões mais
restritas do
problema~\cite{eppstein:siamjc-28-652,katoh:n-12-411,hershberger:acmta-3-??}.
Várias melhorias práticas do método de Yen têm sido implementadas e
testadas~\cite{brander:370,eleni:n-34-88,martins:qjbfiors-1-121,martins:relatorio,perko:n-16-149}

Antes de prosseguirmos, mencionamos que o método de Yen foi generalizado por
Eugene L. Lawler~\cite{lawler:ms-18-401} para problemas de otimização
combinatória, contanto que seja fornecida uma subrotina para determinar uma
solução ótima sujeita a condição de que certas variáveis têm seus valores
fixados. Por exemplo, no caso do método de Yen para o \kCM{} essa subrotina
resolve o seguinte \defi{problema do sub-caminho mínimo}\index{problema!do
sub-caminho mínimo@do sub-caminhos mínimo}, denotado por \PSM:
 \begin{quote}
   \textbf{Problema} \PSM$(V,A,c,s,t,P,F)$:%
   \index{PSM@\PSM}\mar{\PSM}
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   Dado um grafo $(V,A)$, uma função
   custo $c$, dois vértice $s$ e $t$, um caminho $P$ e uma parte $F$ de $A$, 
   encontrar um caminho de custo mínimo 
   de $s$ a~$t$ que tem $P$ como prefixo e não contém arcos em $F$.
 \end{quote}
É evidente que se $P$ não tem início em $s$ então o problema é
inviável. Do ponto de vista de método Lawler, o prefixo $P$ e o conjunto $F$
são as `variáveis' com valores fixados. 
 
Resolver o \PCM$(V,A,c,s,t)$ é o mesmo que resolver
\PSM$(V,A,c,s,t,\seq{s},\emptyset)$.  Por outro lado, o
\PSM{} pode ser solucionado aplicando-se um algoritmo para o
\PCM{} em um sub-grafo apropriado de $(V,A)$.  Desta forma, o
\PCM{} e o \PSM{} são computacionalmente equivalentes e
podem ser resolvidos em tempo $T(n,m)$.


Conceitualmente, o método de Yen é uma elaboração do método \YenGenerico.
No início de cada iteração da linha~2, $\Lcal$ é uma lista dos
candidatos a $i$-ésimo caminho mínimo de $s$ a~$t$. 
Ao invés da partição  $\Pi$ 
de $\Pcal$, Yen mantém em $\Lcal$ um caminho mínimo de
cada parte de $\Pi$. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%de $\Pcal$ em não mais do que $2i$ partes e uma lista $L$ com 
%um caminho mais barato de cada uma das partes. 
Em cada iteração é escolhido  o caminho mais barato entre 
todos em $\Lcal$  e a partição é \textit{levemente} atualizada.

\begin{algoritmo}

\textbf{Método} \Yen{} $(V,A,c,s,t,k)$ %\\[2mm]
   

1\x $\Lcal \larr \{ \mbox{um caminho de custo mínimo de $s$ a $t$} \}$

2\x $\Qcal \larr \emptyset$

3\x \para{} $i=1,\ldots,k$ \faca %\\[1mm]

4\xx  $P_i \larr \mbox{caminho de custo mínimo em $\Lcal$}$
%\\[1mm]

%4\xx  $\Lcal \larr \Lcal \setminus \{P_i\}$

5\xx  $\Qcal \larr \Qcal \cup \{P_i\}$

6\xx  $\Lcal \larr \Atualize~(V,A,c,\Qcal)$

7\x \devolva{} $\seq{P_1,\ldots,P_k}$

\end{algoritmo}


%%Na verdade, com o número dos caminhos em $\Pcal$ é muito grande


\begin{algoritmo}

\textbf{Algoritmo} \Atualize{} $(V,A,c,\Qcal)$ %\\[2mm]
   
0\x $\Lcal \larr \emptyset$

1\x $(N,E,f) \larr$ árvore dos prefixos de $\Qcal$

2\x \para{} \cada{} $u \in N$ \faca %\\[1mm]

3\xx  $P_u \larr \mbox{caminho de $s$ a~$t$ de custo mínimo com prefixo $f(R_u)$}$

\xxxxx e que não possui arcos em $A_u$

4\xx  $\Lcal \larr  \Lcal \cup \{P_u\}$ %\\[1mm]

5\x \devolva{} $\Lcal$


\end{algoritmo}


Na linha~3 do algoritmo \Atualize{}, na verdade, 
estamos resolvendo 
o problema \PSM $(V,A,c,s,t,f(R_u),A_u)$. Assim, o consumo de tempo do
  algoritmo resultante é $n \, i \, T(n,m))$. Em chamadas consecutivas do
  algoritmo \Atualize{}, as árvores dos prefixos calculadas são muito
  semelhantes.
%Logo, é possível fazermos com que o consumo de tempo seja $n \, T(n,m)$.
De fato, o algoritmo  pode ser implementado de tal maneira
que o consumo o seu consumo de tempo seja $n \, T(n,m)$.

O método de \Yen{} pode ser implementado de tal maneira que o seu consumo de
tempo seja proporcional a $k \, n \, T(n,m)$.



\section{Histórico e plano}


Meu primeiro contato com o \kCM\ foi através do problema apresentado na
introdução. Inicialmente, estudei o algoritmo de Naoki Katoh,
Toshihide Ibaraki e H. Mine~\cite{katoh:n-12-411} (KIM) de uma maneira
não-acadêmica, objetivando implementá-lo.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Nosso primeiro contato com o \kCM\ foi através do algoritmo de Naoki Katoh,
%% Toshihide Ibaraki e H. Mine~\cite{katoh:n-12-411} (KIM) de uma maneira
%% não-acadêmica, objetivando implementá-lo para resolver o 
%% problema apresentado na
%% introdução.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Mais tarde, decidimos usar o \kCM\ e os algoritmos para resolvê-los como tema
central do mestrado e passamos a estudar o algoritmo de KIM sobre um novo
ponto de vista: entender sua essência, subrotinas, peculiaridades e, além
disso, procurarmos semelhanças e diferenças com os demais algoritmos
existentes para o mesmo problema.  

O foco inicial do trabalho foi entender o algoritmo
KIM para, num momento posterior, estudar a viabilidade de algumas mudanças
experimentais que pudessem melhorar seu desempenho em grafos especiais ou,
quem sabe, até em grafos genéricos.  Durante a implementação do algoritmo KIM
realizada na TeleMax, tive algumas idéias para melhorar o seu desempenho para
o grafo que representava a rede de dados da TeleMax.  Devido aos prazos curtos
e, principalmente ao fato da implementação ter atendido aos requisitos de
desempenho, não foi possível justificar orçamento para a análise e
implementação das melhorias pensadas.  Gostaria, nesta dissertação de
mestrado, de apresentar a motivação do estudo do algoritmo KIM para o problema
\kCM, estudá-lo à luz do método de Yen do qual ele é derivado,
descrevê-lo de uma maneira mais simples, sem toda a especificidade de um
pseudo-código, apresentar algumas melhorias, implementá-las e avaliar os seus
desempenhos.


Até o momento estudamos o artigo de KIM,  bastante
adequado para aqueles que desejam apenas implementar o algoritmo, uma vez que
o pseudo-código é apresentado em grande detalhe. 
A linguagem bastante carregada dificultou um entendimento do algoritmo em linhas gerais, razão que nos levou
a buscar outra fonte.  Embora não seja apenas um
novo artigo sobre o algoritmo KIM, o trabalho de 
John Hershberger, Matthew Maxel e Subhash Suri~\cite{hershberger:acmta-3-??} 
é classificado pelos autores como uma
extensão do algoritmo KIM para grafos dirigidos.  O grande mérito deste
artigo, do nosso ponto de vista, não é o da apresentação de um novo algoritmo
para o problema \kCM, mas sim pela descrição do problema \kCM{} e das idéias
subjacentes na elaboração do algoritmo, apresentadas de uma maneira bem mais
simples de ser compreendida, sem o abuso de notações pesadas, como as do
artigo KIM. 

Após algumas horas de estudo do  artigo de Hershberger, Maxel e Suri,
decidimos dar mais atenção ao método base para o problema \kCM, o método 
de Yen. 
Nosso objetivo era encontrar os fundamentos e as idéias mais gerais que
permeavam, segundo nosso entendimento, todos os algoritmos para o 
problema \kCM.  


A descrição do método de Yen~\cite{yen:ms-17-712} é bem sucinta, mas
foi suficiente para entendermos algumas idéias.  O plano agora é nos
debruçarmos sobre o artigo de KIM, tendo como bagagem o aprendizado
ganho dos trabalhos de Yen e de Hershberger, Maxel e Suri, lembrando
que uma revisão destes artigos é recomendada.
Após um entendimento melhor, passaremos à redação de um descrição mais
``alto-nível'' do algoritmo de KIM.


Pretendemos experimentar algumas mudanças no algoritmo KIM, e avaliar o quanto
elas significam em ganho de desempenho.  De antemão, sabemos que estas
mudanças não acarretarão em melhoras assintóticas, mas acreditamos que
conseguiremos alcançar desempenhos significativamente superiores.
Como o algoritmo KIM tem como subrotina a geração de
  árvores de caminhos mínimos e, como foi constatado em Eleni Hadjiconstantinou e
 Nicos Christofides~\cite{eleni:n-34-88} que essa subrotina
responde pela maior parte do processamento do algoritmo,
estudaremos o algoritmo para a reconstrução de árvores
de caminhos mínimos descrito por Enrico Nardelli, Guido Proietti e Peter
Widmayer~\cite{nardelli:a-35-56}.  Resumidamente, se trata de um algoritmo
para o seguinte problema: dada uma árvore de caminhos mínimos para um grafo
$G$ encontrar a árvore de caminhos mínimos para o grafo $G'$ derivado de $G$
pela remoção de algumas arestas e vértices. Acreditamos
que melhorias neste ponto do algoritmo possam levar a grandes ganhos de
desempenho.  O artigo de Alberto Marchetti-Spaccamela e Umberto
Nanni~\cite{marchetti:n-16-149} também está relacionado ao problema de
reconstrução de árvores e faz parte da nossa agenda.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%, uma vez que observamos %
%muitas semelhanças entres os grafos geradores das árvores de menores
%caminhos.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






Vamos implementar uma versão bem crua dos algoritmos de Yen e KIM
e algumas versões do algoritmo KIM usando as diversas alterações que pretendemos
analisar.  A idéia é construir uma versão para cada alteração proposta, outra
com grupos de alterações escolhidas de modo a cobrir todos os casos.  
Em seguida, seguiremos com análises comparativas das versões utilizando diversos tipos de grafos
gerados aleatoriamente.





Na tabela a seguir apresentamos, em linhas gerais, as diversas atividades para
a execução do projeto, bem como uma expectativa de
cumprimento destas atividades nos diversos meses do projeto.

\vspace{1cm} 
\tiny 
\noindent
\begin{tabular}{|l||c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
Atividade 
          &  \textsc{mar}  & \textsc{abr} & \textsc{mai} & \textsc{jun} & \textsc{jul} & \textsc{ago} & \textsc{set} & \textsc{out}  & \textsc{nov} & \textsc{dez} & \textsc{jan} & \textsc{fev}    \\
\hline
\hline
Estudo de Yen\cite{yen:ms-17-712}  
&$\surd$ &$\surd$ & & & & & & & & & & \\
\hline
Estudo de Hershberger\cite{hershberger:acmta-3-??}
 & & &$\surd$ &$\surd$ & & & & & & & & \\
\hline
Estudo de Katoh\cite{katoh:n-12-411}
  & &$\surd$ &$\surd$ & & & & & & & & &   
\\ 
\hline
Estudo de Nardelli\cite{nardelli:a-35-56}
  & & & & &$\surd$ &$\surd$ &$\surd$ & & & & &  
\\ 
\hline
Implementações e comparativos
  & & & &$\surd$ &$\surd$ &$\surd$ & $\surd$ &$\surd$ &$\surd$ &$\surd$ & $\surd$ & $\surd$ 
\\ 
\hline
Redação da dissertação & & & &$\surd$ & $\surd$& $\surd$& $\surd$& $\surd$& $\surd$& $\surd$& $\surd$&$\surd$ \\
\hline
Defesa da dissertação  & & & & & & & & & & & &$\surd$ \\
\hline
\hline
\end{tabular}


\normalsize
\vspace{1cm} 

Algumas atividades, como as implementações e a redação da dissertação, estarão presentes durante todo o projeto, razão pela qual aparecem na tabela anterior
na maior parte dos meses.


Apesar de não pretendermos estudar o trabalho de David
Eppstein~\cite{eppstein:siamjc-28-652}, consideramos necessário, pelo menos,
mencioná-lo neste ponto. Eppstein trata do problema de encontrar
$k$-menores passeios, ou seja, pode haver repetição de vértices. 
Apesar desse problema parecer levemente diferente do \kCM, ele 
admite soluções muito mais eficientes.



%%%%%%%%%%%%%%%%%%%%%%% Bibliografia %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\cite{*}
\newpage 
\bibliographystyle{./bib/joseplain} 
\bibliography{./bib/refs}

\end{document}





A seguir mostramos um esboço da estrutura da dissertação.
\begin{enumerate}[1.]
\item Grafos e nomenclatura: ... 
\item Problema \kCM: 
\item Método de Yen:
\item Algoritmo de KIM
\item Melhorias no algoritmo KIM
\begin{enumerate}
     \item \textit{Swap egde}
     \item Custos inteiros
     \item Partição 
\end{enumerate}
\end{enumerate}











 
A \defi{árvore dos prefixos} de $\{P_1,\ldots,P_i\}$ é uma
árvore enraizada junto com uma função que associa um rótulo a
cada nó e a cada aresta da árvore. Suponha que 

Sejam $P_1,\ldots,P_i$ 
caminhos distintos de $s$ a~$t$ em um grafo, $V'$ e $A'$ 
o conjunto dos vértices e arcos presentes  nos caminhos, 
respectivamente.

Suponha que $(N,E)$ é uma árvore com raiz $r$, conjunto de nós $N$ 
e conjunto de arestas $E$. Suponha ainda que $f$ é uma função 
rótulo que associa a cada nó em $N$ um vértice em $V'$ e a cada aresta em $E$ 
um arco em $A$. Diremos que $(N,E,r,f)$ é uma \defi{árvore dos caminhos}  
$\{P_1,\ldots,P_i\}$ se para cada caminho 
 \begin{eqnarray*}
 \seq{r=u_{0}, e_{1}, u_{1}, \ldots, e_{t}, u_{t}}
 \end{eqnarray*}
de $r$ a uma folha $u_t$ de $(N,E)$ temos que
 \begin{eqnarray*}
 \seq{f(r)=f(u_{0}), f(e_{1}), f(u_{1}), \ldots, f(e_{t}), u_{t}}
 \end{eqnarray*}
é um caminho em $\{P_1,\ldots,P_i\}$


Seja $\Rcal$ uma coleção de caminhos em  
caminhos distintos em um grafo e sejam $V'$ e $A'$ 
o conjunto dos vértices e arcos presentes nos caminhos, 
respectivamente.

Suponha que $(N,E)$ é uma árvore com raiz $r$, conjunto de nós $N$ 
e conjunto de arestas $E$. Suponha ainda que $f$ é uma função 
rótulo que associa a cada nó em $N$ um vértice em $V'$ e a cada aresta em $E$ 
um arco em $A$. Se 
\begin{eqnarray*}
 Q=\seq{u_{0}, e_{1}, u_{1}, \ldots, e_{t}, u_{t}}
\end{eqnarray*}
é um caminho em  $(N,E)$, então
\begin{eqnarray*}
 f(Q):=\seq{f(u_{0}), f(e_{1}), f(u_{1}), \ldots, f(e_{t}), u_{t}}
\end{eqnarray*}
Assim, $f(Q)$ é uma seqüência de vértices e arcos nos caminhos 

Diremos que $(N,E,r,f)$ é uma \defi{árvore dos caminhos}  
$\Qcal$ se para cada caminho 
 \begin{eqnarray*}
 \seq{r=u_{0}, e_{1}, u_{1}, \ldots, e_{t}, u_{t}}
 \end{eqnarray*}
em $(N,E)$ de $r$ a uma folha $u_t$ corresponde a um único
caminho
 \begin{eqnarray*}
 \seq{f(r)=f(u_{0}), f(e_{1}), f(u_{1}), \ldots, f(e_{t}), u_{t}}
 \end{eqnarray*}
em $\Qcal$. Ademais, cada caminho em $\Qcal$  



 
um vértice em raiz 

que cada nó e cada aresta possui um rótulo. Os
nós são rotulados com vértices de


 


todos os caminhos em uma mesma 
parte têm um prefixo comum. 

