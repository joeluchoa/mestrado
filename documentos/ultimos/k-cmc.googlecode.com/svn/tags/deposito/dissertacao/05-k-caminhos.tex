%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  CAPÍTULO. CAMINHO MÏNIMO 
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{Problema dos $k$-menores caminhos}
\label{cap:problema-k-caminhos}

Estão descritos neste capítulo os ingredientes básicos que envolvem o
problema dos $k$-menores caminhos, tais como função comprimento, função
potencial, função predecessor, critério de otimalidade, etc. A referência
básica para este capítulo é Feofillof~\cite{pf:aula}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  SEÇÃO: Descrição
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Caminho mínimo}
\label{sec:problema-descricao-kCM}

%
% função custo
%

Uma \defi{função custo}\index{função@função!custo}\index{custo} em
$(V,A)$ é uma função de $A$ em $\NonnegInt$. Se $c$ for uma função
custo em $(V,A)$ e $uv$ estiver em $A$, então
$c(u,v)$ será o valor de $c$ em $uv$. 
%
% Custo de um passeio e passeio de custo mínimo.
% 
Se $P$ for um passeio em um grafo $(V,A)$ e $c$ uma função custo, 
denotaremos por $c(P)$ o \defi{custo do caminho} $P$%
\index{custo do caminho}, ou seja, $c(P)$ é o somatório dos custos
de todos os arcos em $P$.  Um passeio $P$ tem \defi{custo mínimo} se
$c(P) \leq c(P')$ para todo passeio $P'$ que tenha o mesmo início e término
que $P$. Um passeio de custo mínimo é comumente chamado de \defi{caminho
mínimo}.
 
%
% Problema dos menores caminhos 
% 
 
Um problema fundamental em otimização combinatória que tem um papel de
destaque neste projeto é o 
\defi{problema do caminho mínimo}, denotado por
\PCM:\index{problema!do caminho mínimo@do caminho mínimo}
 \begin{quote}
   \textbf{Problema} \PCM$(V,A,c,s,t)$: 
   \index{\PCM}\mar{\PCM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   Dado um grafo $(V,A)$, uma função
   custo~$c$ e dois vértice $s$ e $t$, 
   encontrar um caminho de custo mínimo 
   de $s$ a~$t$.
 \end{quote}
Na literatura essa versão é conhecida como \textit{single-pair shortest path
problem}\index{single-pair shortest path@single-source shortest path}. 
O celebrado algoritmo de Edsger Wybe Dijkstra~\cite{dijkstra59:note}, que foi descrito no capítulo~\ref{cap:problema-CM}
resolve o problema do caminho mínimo.



Denotaremos, quando não houver
ambigüidade, por $n$ e $m$ os números $|V|$ e $|A|$, respectivamente.
Além disso, representaremos por $T(n,m)$ o consumo de tempo de uma
subrotina genérica para resolver o \PCM\ em um grafo com $n$ vértices
e $m$ arestas.
O algoritmo mais eficiente  conhecido para o \PCM\ foi 
projetado por Michael L. Fredman e Robert Endre
Tarjan~\cite{FredTarjan:Fibonacci}
e consome tempo $\Oh(m + n \log n)$. Existe ainda um algoritmo que consome
tempo linear \textit{sob um outro modelo de computação} que foi
desenvolvido por Mikkel Thorup~\cite{thorup:sssp-1999}.    


Uma \defi{função comprimento}\index{funcao@@função!comprimento} %
\index{comprimento!funcao@@função} em
$(V,A)$ é uma função de $A$ em $\NonnegInt$. Se $c$ é uma função
comprimento em $(V,A)$ e $uv$ está em $A$, então, denotaremos por
$c(u,v)$ o valor de $c$ em $uv$. 
Se $(V,A)$ é um grafo simétrico e $c$ é 
uma função comprimento em $(V,A)$, então $c$ é 
\defi{simétrica}\index{funcao@@função!comprimento simétrica} se
$c(u,v) = c(v,u)$ para todo arco $uv$.
%%%% CZAO
O \defi{maior comprimento}\index{maior
  comprimento} de um arco será denotado por $C$\mar{$C$}, ou seja, 
$C = \max\{c(u,v) \tq uv \in A \}$.

%%% Comprimento de um passeio e passei de comprimento minimo.
Se $P$ é um passeio em um grafo $(V,A)$ e $c$ é uma função comprimento, 
denotaremos por $c(P)$ o \defi{comprimento do caminho} $P$%
\index{comprimento!do caminho}, ou seja, $c(P)$ é o somatório dos comprimentos
de todos os arcos em $P$.  Um passeio $P$ tem \defi{comprimento mínimo} se
$c(P) \leq c(P')$ para todo passeio $P'$ que tenha o mesmo início e término
que $P$.  A \defi{distância}\index{distancia@@distância} de um vértice $s$ a um
vértice $t$ é o menor comprimento de um caminho de $s$ a $t$. 
A distância de $s$ a $t$ em relação a $c$ será denotada por 
$\distc{s,t}$\index{$\distc{s,t}$}\mar{$\distc{s,t}$}, ou simplesmente, 
quando a função
comprimento estiver subentendida, por
$\dist{s,t}$\index{$\dist{s,t}$}\mar{$\dist{s,t}$}
 denota a distância de $s$ a $t$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  DEFINIÇÃO
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 


\section{$k$-menores caminhos}

O problema central deste projeto se assemelha muito ao  
do $k$-ésimo menor elemento, que é estudado em disciplinas 
básicas de análise de algoritmos:
 \begin{quote}
   \textbf{Problema} \kesimo$(\Scal,k)$:%
 \index{\kesimo}\mar{\kesimo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   Dado um conjunto $\Scal$ de números inteiros 
   e um número inteiro positivo
   $k$, encontrar o $k$-ésimo menor elemento de $\Scal$.
 \end{quote}
Os algoritmos conhecidos para o problema \kesimo\ são
facilmente adap\-tá\-veis para, além do $k$-ésimo menor, fornecerem, em tempo 
linear, os $k$ menores elementos de $\Scal$ \textit{em ordem crescente}.

A diferença entre o problema \kesimo\ e o problema que
consideraremos é que o conjunto $\Scal$ dado é ``muito grande'' e, portanto,
nos é dado de uma maneira compacta, o que torna o problema sensivelmente
mais difícil do ponto de vista computacional. 
%O conjunto $\Scal$ será o conjunto de caminhos entre dois vértices
%determinados  em um grafo com custo
%nas nos arcos. 
Adiante tornamos o problema mais preciso.  

Suponha que $(V,A)$ seja um grafo, $c$ uma função custo e $s$ e $t$ 
dois de seus vértices. Considere o conjunto $\Pcal_{st}$ de todos $st$-caminhos,
ou seja, caminhos de $s$ a~$t$. 
Uma lista $\seq{P_1,\ldots,P_k}$ $st$-caminhos  distintos é de \defi{custo mínimo} se 
$$
c(P_1) \leq c(P_2) \leq \cdots \leq c(P_k) \leq \min\{ c(P) : P
\in \Pcal -\{P_1,\ldots,P_k\}\}.
$$
De uma maneira mais breve, diremos que $\seq{P_1,\ldots,P_k}$ são 
\defi{$k$-menores caminhos} (de $s$ a~$t$).

Em termos da teoria dos grafos o  problema que foi discutido na 
introdução é o \defi{problema dos $k$-menores caminhos}\index{problema!dos
k-menores caminhos@do $k$-menores caminhos}, denotado por \kCM:
 \begin{quote}
   \textbf{Problema} \kCM$(V,A,c,s,t,k)$:%
   \index{\kCM}\mar{\kCM}
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   Dado um grafo $(V,A)$, uma função
   custo $c$, dois vértice $s$ e $t$ e um inteiro positivo $k$, 
   encontrar $k$-caminhos de custos mínimos 
   de $s$ a~$t$.
 \end{quote}
É evidente que o \PCM\ nada mais é que o \kCM\ com $k=1$.

O \kCM\ é, em essência, o problema \kesimo\ com $\Pcal_{st}$ no papel do
conjunto $\Scal$. A grande diferença computacional é que o conjunto
$\Pcal_{st}$ não é fornecido explicitamente, mas sim de uma maneira
compacta: um grafo, uma função custo e um par de vértices. Desta
forma, o número de elementos em $\Pcal_{st}$ é potencialmente exponencial no
tamanho da entrada, tornando impraticável resolvermos o \kCM\
utilizando meramente algoritmos para o \kesimo\ como subrotina.

Na próxima seção é descrito o método genérico para resolver o \kCM.
Este método é um passo intermediário para chegarmos no método desenvolvido 
por Jin Y. Yen~\cite{yen:ms-17-712}  para o \kCM.
Antes disto, apresentamos aqui um problema intimamente 
relacionado ao \kCM\ e que também é considerado por este projeto: 

\begin{quote}
  \textbf{Problema} \KCM$(V,A,c,s,t,K)$:%
  \index{\KCM}\mar{\KCM}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Dado um grafo $(V,A)$, uma função
  custo $c$, dois vértice $s$ e $t$ e um inteiro positivo $K$, 
  encontrar os caminhos de $s$ a~$t$ de custos não superiores a $K$.
\end{quote}


%\section{Definição do problema}

 Formalmente, nesta dissertação, estamos interessados no seguinte
 \defi{problema do caminho mínimo}:%
 \index{problema!do caminho minimo@@do caminho mínimo}
\begin{quote}
\textbf{Problema} PCM$(V,A,c,s)$:%
\index{PCM}\mar{PCM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Dado um grafo $(V,A)$, uma função
comprimento $c$ e um vértice $s$, encontrar um caminho de 
comprimento mínimo de $s$ até $t$, para cada vértice $t$ em $V$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Os caminhos de comprimento mínimo serão devolvidos através de:
% \begin{enumerate}
% \item[\iten{1}] uma função potencial viável $\fp{}$ e
% \item[\iten{2}] uma função predecessor $\pred$ 
% \end{enumerate}
% \textbf{satisfazendo:}

%  se $\fp(t) - \fp(s) < nC$

%  \x então $c(P) = \fp(t) - \fp(s)$,

%  onde $P$ é um caminho de $s$ a $t$ determinado por $\pred$.
\end{quote}
Na literatura essa versão é conhecida como \textit{single-source shortest path
 problem.}\index{single source@@single-source shortest path}
 
 
\section{\'Arvores dos prefixos}


Descrevemos aqui uma ``arborescência rotulada'' que de certa forma
codifica os prefixos dos caminhos em uma dada coleção.
Esta representação será particularmente útil quando, mais
adiante, discutirmos o método de Yen.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
No que segue $\Qcal$ é uma coleção de caminhos de um grafo e  
$V(\Qcal)$ e $A(\Qcal)$ são o conjunto dos vértices e o
conjunto dos arcos presentes nos caminhos, respectivamente.

Um grafo acíclico $(N,E)$ com $|N| = |E| + 1$ é uma
\defi{arborescência}\index{arborescencia@@arborescência} 
se todo vértice, exceto um 
vértice especial chamado de 
\defi{raiz}\index{raiz da arborescência@@raiz da arborescência},
 for ponta final de exatamente um arco. 
Será conveniente tratarmos os vértices 
de uma arborescência por \defi{n\'os}. 
Uma arborescência está ilustrada na 
figura~\ref{fig:grafo}(c). 
A raiz dessa arborescência é o
n\'o $a$. Uma \defi{folha}\index{folha de uma arborescência@@folha de uma
arborescência}
de uma arborescência é um n\'o
que não é ponta inicial de nenhum arco. 


Suponha que $(N,E)$ seja uma arborescência e  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$f$ uma \defi{função r\'otulo}\index{função@função!rotulo@r\'otulo} 
que associa a cada n\'o em $N$ um vértice em $V(\Qcal)$ e a
cada arco em $E$ um arco em $A(\Qcal)$. 
Se 
\begin{eqnarray*}
 R=\seq{u_{0}, e_{1}, u_{1}, \ldots, e_{t}, u_{t}}
\end{eqnarray*}
for um caminho em  $(N,E)$, então
\begin{eqnarray*}
 f(R):=\seq{f(u_{0}), f(e_{1}), f(u_{1}), \ldots, f(e_{t}), f(u_{t})}
\end{eqnarray*}
será uma seqüência de vértices e arcos dos caminhos em $\Qcal$.
Diremos que $(N,E,f)$ é \defi{árvore dos prefixos} de $\Qcal$ se 
\begin{enumerate}[(p1)]
\item para cada caminho $R$ em $(N,E)$ com início na
      raiz, $f(R)$ for prefixo de algum caminho em $\Qcal$; e
\item para cada prefixo $Q$ de algum caminho em $\Qcal$
      existir um caminho $R$ em $(N,E)$ com início na
      raiz tal que $f(R)=Q$; e
\item o caminho $R$ do item anterior for único. 
\end{enumerate}

Não é verdade que para cada coleção $\Qcal$ de caminhos em
um grafo existe uma árvore dos prefixos de $\Qcal$.
No entanto, se todos os caminhos em $\Qcal$
tiverem a mesma ponta inicial, então existe uma árvore dos prefixo de
$\Qcal$ e esta é única. Na figura~\ref{fig:prefixo}(b) vemos 
a ilustração da árvore dos prefixos de quatro caminhos de $s$ a~$t$ no grafo
da figura~\ref{fig:prefixo}(a). Na árvore da ilustração $w,x,y$ 
e $z$ são n\'os e $f(w)=s, f(x)=a, f(y)=d$ e $f(z)=d$.

\begin{figure}[htbp]
 \begin{center}
    \psfrag{(a)}{$\iten{a}$}
    \psfrag{(b)}{$\iten{b}$}
    \psfrag{a}{{$s$}}
    \psfrag{b}{{$a$}}
    \psfrag{c}{{$b$}}
    \psfrag{d}{{$c$}}
    \psfrag{e}{{$d$}}   
    \psfrag{f}{{$t$}}
    \psfrag{x}{{$x$}}
    \psfrag{y}{{$y$}}
    \psfrag{z}{{$z$}}
    \psfrag{w}{{$w$}}
    \psfrag{grafo}{grafo}
    \psfrag{arvore dos prefixos}{árvore dos prefixos}
  \includegraphics{./figs/prefixo.eps}
  \caption{\label{fig:prefixo} (b) mostra a árvore dos prefixos dos
   caminhos
   $\seq{s,a,c,t}$,
   $\seq{s,a,d,t}$,
   $\seq{s,b,a,c,t}$ e 
   $\seq{s,b,a,d,c,t}$ no grafo em~(a).
  Na árvore, um símbolo ao lado de um n\'o é o r\'otulo desse n\'o.
  Os r\'otulos dos arcos não estão representados na figura. O símbolo 
  dentro de um n\'o é o seu nome.
  }
 \end{center}
 \end{figure}






\section{Método genérico}

A descrição que fazemos é, de certa forma, \textit{top-down}. 
Começaremos com um método genérico que será refinado a cada passo incluindo,
convenientemente, algumas subrotinas auxiliares.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
O nosso interesse aqui é numa descrição mais conceitual em que 
a correção e o consumo de tempo polinomial do método sejam um tanto quanto
evidentes. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Não temos a intenção de descrever um algoritmo com o menor consumo de tempo. 

O método abaixo recebe um grafo $(V,A)$, uma função custo, dois vértices $s$ e
$t$ e um inteiro positivo $k$ e devolve uma lista $\seq{P_1,\ldots,P_k}$ de
$k$-menores caminhos de $s$ a~$t$.

\begin{algoritmo}

\textbf{Método} \Generico{} $(V,A,c,s,t,k)$ %\\[2mm]
   
0\x $\Pcal \larr \mbox{conjunto dos caminhos de $s$ a~$t$}$ 

1\x \para{} $i=1,\ldots,k$ \faca %\\[1mm]

2\xx  $P_i \larr \mbox{caminho de custo mínimo em $\Pcal$}$ %\\[1mm]

3\xx  $\Pcal \larr \Pcal - P_i$

4\x \devolva{} $\seq{P_1,\ldots,P_k}$

\end{algoritmo}

No início de cada iteração da linha~1 o conjunto $\Pcal$ contém os
candidatos a $i$-ésimo caminho mínimo de $s$ a~$t$. 
O método de Yen é uma elaboração do método \Generico.
Em vez do conjunto 
$\Pcal$, Yen mantém, pelo menos conceitualmente, uma partição
$\Pi$ de $\Pcal$.
Em cada iteração, é escolhido o caminho mais barato
dentre um conjunto $\Lcal$ formado por \textit{um} caminho 
mínimo $P_{\pi}$ representante de
cada parte $\pi$ de~$\Pi$ e depois a partição é atualizada. 

\begin{algoritmo}

\textbf{Método} \YenGenerico{} $(V,A,c,s,t,k)$ %\\[2mm]
   
0\x $\Pi \larr \{\{\mbox{conjunto dos caminhos de $s$ a~$t$}\}\}$

1\x $\Qcal \larr \emptyset $

2\x \para{} $i=1,\ldots,k$ \faca %\\[1mm]

3\xx  $\Lcal  \larr \seq{P_{\pi} : P_{\pi} \ \mbox{é caminho mínimo da parte $\pi$
de~$\Pi$}}$

4\xx  $P_i \larr \mbox{caminho de custo mínimo em $\Lcal$}$ %\\[1mm]

5\xx  $\Qcal \larr \Qcal \cup \{P_i\}$

6\xx  $\Pi \larr \AtualizeGenerico~(V,A,\Qcal)$

7\x \devolva{} $\seq{P_1,\ldots,P_k}$

\end{algoritmo}

Como veremos, a eficiência do método de Yen dependerá fortemente da estrutura
restrita dos caminhos nas partes de~$\Pi$: cada parte é formada por
caminhos que têm um certo prefixo comum. 

Seja $\Pcal_{st}$ a coleção
dos caminhos de $s$ a~$t$ em $(V,A)$.
Suponha que $\Qcal$ seja a lista de 
caminhos distintos de $s$ a~$t$ na linha~5 do método
\YenGenerico{}.  Passamos a descrever a partição
$\Pi$ dos caminhos em $\Pcal := \Pcal_{st} \setminus \Qcal$.
Para isto é conveniente utilizarmos a 
\textit{árvore dos prefixos} de
$\Qcal$, como foi feito por John Hershberger,
Matthew Maxel e Subhash Suri~\cite{hershberger:acmta-3-??}.

No que segue suponha que $(N,E,f)$ seja 
a árvore dos prefixos de $\Qcal$ e $u$ seja um n\'o em $N$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Representaremos por $R_u$\mar{$R_u$} o
caminho da raiz a $u$ na árvore. Assim,  $f(R_u)$\mar{$f(R_u)$} é
o prefixo de um caminho em $\Qcal$. 
Por exemplo, na árvore dos prefixos da figura~\ref{fig:prefixo}(b)
temos que $R_y = \seq{w,wx,x,xy,y}$ e $f(R_y) = \seq{s,sa,a,ad,d}$.

Seja\mar{$A_u$}
%$A_u$ a
%coleção dos arcos em $A$ com ponta inicial em $f(u)$ e
%ponta final $f(w)$ para todo arco $uw$ em $E$, isto é,
\begin{eqnarray*}
A_u := \{ (f(u),f(w)) : uw \in E\}. 
\end{eqnarray*}  
e seja $\pi_u$\mar{$\pi_u$} o conjunto dos caminhos em $\Pcal$ com
prefixo $f(R_u)$ e que não possuem arcos em~$A_u$.
Para o exemplo na figura~\ref{fig:prefixo} temos que 
\begin{eqnarray*}
A_w = \{sa,sb\}, 
A_x = \{ac,ad\}, 
A_y = \{dt\} \ \mbox{e} \ 
A_z = \{dc\} \\
\pi_w = \emptyset, 
\pi_x = \emptyset,
\pi_y = \{\seq{s,a,d,c,t}\},  \ \mbox{e} \
\pi_z = \{\seq{s,b,a,d,t}\}.  
\end{eqnarray*}

A partição~$\Pi$\mar{$\Pi$} é formada por uma parte $\pi_u$ para
cada vértice $u$ em $N$, ou seja,
\[
\Pi := \{\pi_u : u \in N\}.
\]
No início de cada iteração da linha~2 o número de partes é certamente não
superior a $n \times i$.
O algoritmo \AtualizeGenerico{} resume toda a discussão acima.


\begin{algoritmo}

\textbf{Algoritmo} \AtualizeGenerico{} $(V,A,\Qcal)$ %\\[2mm]
   
0\x $\Pi \larr \emptyset \quad \quad \Pcal \larr \Pcal_{st} \setminus \Qcal$

1\x $(N,E,f) \larr$ árvore dos prefixos de $\Qcal$

2\x \para{} \cada{} $u \in N$ \faca %\\[1mm]

3\xx  $\pi_u \larr \{\mbox{caminhos em $\Pcal$ com prefixo $f(R_u)$}$

\xxxxx \quad e que não possuem arcos em $A_u \}$

4\xx  $\Pi \larr  \Pi \cup \{\pi_u\}$ %\\[1mm]

5\x \devolva{} $\Pi$

\end{algoritmo}

Podemos verificar que cada caminho em $\Qcal$ não pertence a
nenhuma parte de~$\Pi$. Também podemos verificar que cada
caminho $P$ em $\Pcal$ está em uma única 
parte de~$\Pi$. De fato, seja $P'$ o maior prefixo de~$P$ 
que é prefixo de algum caminho em $\Qcal$. Pela definição
de árvore de prefixos, existe um único caminho $R'$ em 
$(N,E)$ com início na raiz e tal que $P' = f(R')$. 
Para o vértice $u$ término de $R'$ temos que $P$ está em
$\pi_u$ e é a única parte que possui $P$. 

Desta forma, no início de cada iteração das linhas
2--6  do método \YenGenerico{}, $\Pi$ é uma partição de
$\Pcal$, portanto a correção
do método é evidente.


%% ???Ainda utilizando a estrutura da árvore dos prefixos de  

As árvores dos prefixos de duas
execuç\~oes consecutivas do algoritmo \AtualizeGenerico{} são
muito semelhantes: apenas um novo caminho é acrescentado à
árvore anterior.  Isto, em particular, significa que as
partiç\~oes de duas iteraç\~oes consecutivas das linhas 2--6 do
método \YenGenerico{} são muitos semelhantes. Esta
observação pode ser utilizada para o algoritmo
\AtualizeGenerico{} obter mais eficientemente
uma partição a partir da partição anterior.
 





\section{Método de Yen}

O método que Jin Y. Yen~\cite{yen:ms-17-712} desenvolveu para resolver
o \kCM{} parece ter um papel central entre os algoritmos que foram
posteriormente projetados para o \kCM\ ou mesmo para vers\~oes mais
restritas do
problema~\cite{eppstein:siamjc-28-652,katoh:n-12-411,hershberger:acmta-3-??}.
Várias melhorias práticas do método de Yen têm sido implementadas e
testadas~\cite{brander:370,eleni:n-34-88,martins:qjbfiors-1-121,martins:relatorio,perko:n-16-149}

Antes de prosseguirmos, mencionamos que o método de Yen foi generalizado por
Eugene L. Lawler~\cite{lawler:ms-18-401} para problemas de otimização
combinat\'oria, contanto que seja fornecida uma subrotina para determinar uma
solução \'otima sujeita a condição de que certas variáveis têm seus valores
fixados. Por exemplo, no caso do método de Yen para o \kCM{} essa subrotina
resolve o seguinte \defi{problema do sub-caminho mínimo}\index{problema!do
sub-caminho mínimo@do sub-caminhos mínimo}, denotado por \PSM:
 \begin{quote}
   \textbf{Problema} \PSM$(V,A,c,s,t,P,F)$:%
   \index{PSM@\PSM}\mar{\PSM}
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   Dado um grafo $(V,A)$, uma função
   custo $c$, dois vértice $s$ e $t$, um caminho $P$ e uma parte $F$ de $A$, 
   encontrar um caminho de custo mínimo 
   de $s$ a~$t$ que tem $P$ como prefixo e não contém arcos em $F$.
 \end{quote}
\'E evidente que se $P$ não tem início em $s$ então o problema é
inviável. Do ponto de vista de método Lawler, o prefixo $P$ e o conjunto $F$
são as `variáveis' com valores fixados. 
 
Resolver o \PCM$(V,A,c,s,t)$ é o mesmo que resolver
\PSM$(V,A,c,s,t,\seq{s},\emptyset)$.  Por outro lado, o
\PSM{} pode ser solucionado aplicando-se um algoritmo para o
\PCM{} em um sub-grafo apropriado de $(V,A)$.  Desta forma, o
\PCM{} e o \PSM{} são computacionalmente equivalentes e
podem ser resolvidos em tempo $T(n,m)$.


Conceitualmente, o método de Yen é uma elaboração do método \YenGenerico.
No início de cada iteração da linha~2, $\Lcal$ é uma lista dos
candidatos a $i$-ésimo caminho mínimo de $s$ a~$t$. 
Ao invés da partição  $\Pi$ 
de $\Pcal$, Yen mantém em $\Lcal$ um caminho mínimo de
cada parte de $\Pi$. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%de $\Pcal$ em não mais do que $2i$ partes e uma lista $L$ com 
%um caminho mais barato de cada uma das partes. 
Em cada iteração é escolhido  o caminho mais barato entre 
todos em $\Lcal$  e a partição é \textit{levemente} atualizada.

\begin{algoritmo}

\textbf{Método} \Yen{} $(V,A,c,s,t,k)$ %\\[2mm]
   

1\x $\Lcal \larr \{ \mbox{um caminho de custo mínimo de $s$ a $t$} \}$

2\x $\Qcal \larr \emptyset$

3\x \para{} $i=1,\ldots,k$ \faca %\\[1mm]

4\xx  $P_i \larr \mbox{caminho de custo mínimo em $\Lcal$}$
%\\[1mm]

%4\xx  $\Lcal \larr \Lcal \setminus \{P_i\}$

5\xx  $\Qcal \larr \Qcal \cup \{P_i\}$

6\xx  $\Lcal \larr \Atualize~(V,A,c,\Qcal)$

7\x \devolva{} $\seq{P_1,\ldots,P_k}$

\end{algoritmo}


%%Na verdade, com o número dos caminhos em $\Pcal$ é muito grande


\begin{algoritmo}

\textbf{Algoritmo} \Atualize{} $(V,A,c,\Qcal)$ %\\[2mm]
   
0\x $\Lcal \larr \emptyset$

1\x $(N,E,f) \larr$ árvore dos prefixos de $\Qcal$

2\x \para{} \cada{} $u \in N$ \faca %\\[1mm]

3\xx  $P_u \larr \mbox{caminho de $s$ a~$t$ de custo mínimo com prefixo $f(R_u)$}$

\xxxxx e que não possui arcos em $A_u$

4\xx  $\Lcal \larr  \Lcal \cup \{P_u\}$ %\\[1mm]

5\x \devolva{} $\Lcal$


\end{algoritmo}


Na linha~3 do algoritmo \Atualize{}, na verdade, 
estamos resolvendo 
o problema \PSM $(V,A,c,s,t,f(R_u),A_u)$. Assim, o consumo de tempo do
  algoritmo resultante é $n \, i \, T(n,m))$. Em chamadas consecutivas do
  algoritmo \Atualize{}, as árvores dos prefixos calculadas são muito
  semelhantes.
%Logo, é possível fazermos com que o consumo de tempo seja $n \, T(n,m)$.
De fato, o algoritmo  pode ser implementado de tal maneira
que o consumo o seu consumo de tempo seja $n \, T(n,m)$.

O método de \Yen{} pode ser implementado de tal maneira que o seu consumo de
tempo seja proporcional a $k \, n \, T(n,m)$.


 
 
 
 
