\section{$\epsilon$-Aproximação}
\label{sec:aproximacao}

\citet{hassin:92} aplicou a técnica de escalar e arredondar para obter 
um esquema de aproximação totalmente polinomial (\fptas~-- \emph{fully 
polynomial $\epsilon$-approximation scheme}) para o \srcsp.  Vamos ver, 
resumidamente, este método agora.

Na seção~\ref{sec:dp} nós vimos alguns procedimentos baseados em 
programação dinâmica. Para nossos propósitos aqui, a programação 
dinâmica dual~(\ref{subsec:dp-dual}) é bastante útil. Nela iteramos 
sobre o valor de custo $c$ até o primeiro valor $c'$ tal que $g_t(c') 
\le \lambda$.  Assim, temos o conhecimento do valor $OPT = c'$. 

Agora, digamos que $V$ seja um inteiro, e suponha que queremos testar se 
$OPT \ge V$ ou não. Um procedimento polinomial que responde essa questão 
poderia ser estendido para obtermos um algoritmo polinomial para 
encontrar $OPT$ simplesmente usando uma busca binária. Como nosso 
problema é $\mathcal{NP}$-difícil, temos que nos satisfazer com um teste 
mais fraco.

Tomemos um $\epsilon$ fixo, $0 < \epsilon < 1$. Agora, nós iremos 
descrever um teste polinomial $\epsilon$-aproximado com as seguintes 
propriedades: se tal teste devolve uma saída positiva, então 
definitivamente $OPT \ge V$.  Se ele devolver uma saída negativa, então 
nós sabemos que $OPT < (V + \epsilon)$.

O teste arredonda o custo $c_{ij}$ dos arcos, substituindo seu valor 
por:

$$ \left\lfloor \frac{ c_{ij} }{ \epsilon V / (n-1) } \right\rfloor 
\cdot \frac{\epsilon V}{(n-1)} $$.

Isto diminui todos os custos de arcos em no máximo $\epsilon V / (n-1)$, 
e todos os custos de caminhos em no máximo $\epsilon V$. Agora o 
problema pode ser resolvido aplicando o algoritmo de programação 
dinâmica dual ao grafo com os custos dos arcos escalados para $\lfloor 
c_{ij} / (\epsilon V / (n-1)) \rfloor$. Os valores de $g_j(c)$ para $j = 
2, ..., n$, são primeiro computados para $c=1$, depois para 
$c=2,3,\cdots$ até que
$g_n(c) \le \lambda$ para algum $c=\hat{c}<(n-1)/\epsilon$, ou $c \ge 
(n-1)/\epsilon$.

No primeiro caso, um caminho de custo de no máximo
$$ \frac{V\epsilon}{n - 1} \hat{c} + V\epsilon < V(1+\epsilon)$$
foi encontrado, e segue que $OPT < V(1+\epsilon)$. No segundo caso, cada 
caminho tem $c' \ge (n-1)/\epsilon$ ou $c \ge V$, então $OPT \ge V$.  
Assim, o teste funciona como queríamos.

A complexidade de tempo é polinomial para um $\epsilon$ fixado, como 
explicada a seguir: Tomar a parte inteira de um número não negativo no 
intervalo $[0, U]$ pode ser feito em tempo $O(\lg(U))$ usando busca 
binária. Arredondar o custo dos arcos toma tempo $O(mlg(n/\epsilon))$ 
desde que nós escalamos somente os arcos com custo menor que $V$ (o 
resultado é no máximo $(n-1)/\epsilon)$. Depois executamos 
$O(n\epsilon)$ iterações do algoritmo acima que novamente toma tempo 
$O(m\lg(n/\epsilon))$. E essa é também a complexidade do procedimento de 
teste inteiro.

Agora nós usamos este teste para chegar a um \fptas~baseado em escalar e 
arredondar: Para aproximar $OPT$ nós primeiramente determinamos um 
limite superior ($UB$) e um limite inferior ($LB$).  O limite superior 
$UB$ pode ser obtido como a soma dos $n-1$ arcos com maior custo, ou o 
custo do caminho que consome menos recursos. O limite inferior $LB$ pode 
ser $0$ ou o caminho de menor custo.

Se $UB \le (1 + \epsilon)LB$, então $UB$ é uma $\epsilon$-aproximação de 
$OPT$. Suponha que $UB > (1+\epsilon)LB$. Seja $V$ um dado valor $LB < V 
< UB/(1+\epsilon)$. O nosso procedimento de teste pode agora ser 
aplicado para melhorar os limites para $OPT$. Especificamente, ou $LB$ é 
aumentado ou $UB$ é diminuído para $V(1+\epsilon)$. Executando uma 
sequência de testes, a razão $UB/LB$ pode ser reduzida. Uma vez que a 
razão atinja o valor de uma constante pré-definida, então uma 
$\epsilon$-aproximação pode ser obtida aplicando-se o algoritmo de
programação dinâmica para o grafo com os custos dos arcos escalados para 
$\lfloor c_{ij} / (LB/(n-1)) \rfloor$. O erro final é no máximo 
$\epsilon LB < \epsilon OPT$.

A complexidade de tempo para o último passo é $O(mn/\epsilon)$. A 
redução da razão $UB/LB$ é melhor alcançada por busca binária no 
intervalo $(LB, UB)$ em escala logarítmica. Depois de cada teste nós 
atualizamos os limites. Para garantir uma rápida redução de razão nós 
executamos o teste com o valor $x$ tal que $UB/x=x/LB$, que é $x = 
(LB\cdot UB)^{1/2}$. Tomando $\epsilon = 2$ por exemplo, o número de 
testes necessários para reduzir a razão para abaixo de $\epsilon$ é 
$O(\lg\lg(UB/LB))$ e cada teste toma tempo $O(mn/\epsilon)$.  
\citet{hassin:92} mostrou como computar um valor inteiro próximo a 
$O(UB\cdot LB)^{1/2}$ em tempo $O(\lg\lg(UB/LB))$.  Isto dá uma 
complexidade de tempo, total de $O(\lg\lg(UB/LB)(m(n\epsilon) + 
\lg\lg(UB/LB)))$ para este algoritmo.

\citet{hassin:92} também mostrou uma \fptas~cuja complexidade depende 
somente do número de variáveis e $1/\epsilon$ e possui complexidade de 
tempo de $O(m(n^2/\epsilon)\lg(n/\epsilon))$.
O melhor \fptas, até o momento, para o \rcsp~foi obtido por 
\citet{phillips:93} que atingiu a complexidade de tempo de 
$O(m(n/\epsilon) + (n^2/\epsilon)\lg(n/\epsilon))$.

